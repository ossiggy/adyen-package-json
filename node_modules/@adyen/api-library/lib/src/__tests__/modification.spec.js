"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const nock_1 = __importDefault(require("nock"));
const base_1 = require("../__mocks__/base");
const checkout_1 = __importDefault(require("../services/checkout"));
const client_1 = __importDefault(require("../client"));
const models_1 = require("../typings/checkout/models");
const httpClientException_1 = __importDefault(require("../httpClient/httpClientException"));
const invalidModificationResult = {
    "status": 422,
    "errorCode": "167",
    "message": "Original pspReference required for this operation",
    "errorType": "validation"
};
const createAmountUpdateRequest = () => {
    return {
        reference: "863620292981235A",
        merchantAccount: process.env.ADYEN_MERCHANT,
        amount: {
            currency: "EUR",
            value: 420
        },
        reason: models_1.CreatePaymentAmountUpdateRequest.ReasonEnum.DelayedCharge
    };
};
const createAmountUpdateResponse = () => {
    return {
        paymentPspReference: "863620292981235A",
        pspReference: "863620292981235B",
        reference: "reference",
        merchantAccount: process.env.ADYEN_MERCHANT,
        amount: {
            currency: "EUR",
            value: 420,
        },
        reason: models_1.CreatePaymentAmountUpdateRequest.ReasonEnum.DelayedCharge,
        status: models_1.PaymentAmountUpdateResource.StatusEnum.Received,
    };
};
const createCancelsRequest = () => {
    return {
        reference: "863620292981235B",
        merchantAccount: process.env.ADYEN_MERCHANT,
    };
};
const createCancelsResponse = () => {
    return {
        merchantAccount: process.env.ADYEN_MERCHANT,
        pspReference: "863620292981235B",
        paymentPspReference: "863620292981235A",
        status: models_1.PaymentCancelResource.StatusEnum.Received,
    };
};
const createStandaloneCancelsRequest = () => {
    return {
        reference: "reference",
        merchantAccount: process.env.ADYEN_MERCHANT,
        paymentReference: "863620292981235B",
    };
};
const createStandaloneCancelsResponse = () => {
    return {
        reference: "reference",
        merchantAccount: process.env.ADYEN_MERCHANT,
        paymentReference: "863620292981235B",
        pspReference: "863620292981235A",
        status: models_1.StandalonePaymentCancelResource.StatusEnum.Received,
    };
};
const createCapturesRequest = () => {
    return {
        reference: "reference",
        merchantAccount: process.env.ADYEN_MERCHANT,
        amount: {
            currency: "EUR",
            value: 420,
        }
    };
};
function createCapturesResponse() {
    return {
        paymentPspReference: "863620292981235A",
        pspReference: "863620292981235B",
        reference: "reference",
        merchantAccount: process.env.ADYEN_MERCHANT,
        amount: {
            currency: "EUR",
            value: 420,
        },
        status: models_1.PaymentCaptureResource.StatusEnum.Received,
    };
}
const createRefundsRequest = () => {
    return {
        merchantAccount: process.env.ADYEN_MERCHANT,
        amount: {
            currency: "EUR",
            value: 420,
        }
    };
};
const createRefundsResponse = () => {
    return {
        paymentPspReference: "863620292981235A",
        pspReference: "863620292981235B",
        reference: "reference",
        merchantAccount: process.env.ADYEN_MERCHANT,
        amount: {
            currency: "EUR",
            value: 420,
        },
        status: models_1.PaymentRefundResource.StatusEnum.Received,
    };
};
const createReversalsRequest = () => {
    return {
        merchantAccount: process.env.ADYEN_MERCHANT
    };
};
const createReversalsResponse = () => {
    return {
        paymentPspReference: "863620292981235A",
        pspReference: "863620292981235B",
        reference: "reference",
        merchantAccount: process.env.ADYEN_MERCHANT,
        status: models_1.PaymentRefundResource.StatusEnum.Received,
    };
};
let client;
let checkout;
let scope;
const paymentPspReference = "863620292981235A";
const invalidPaymentPspReference = "invalid_psp_reference";
const isCI = process.env.CI === "true" || (typeof process.env.CI === "boolean" && process.env.CI);
beforeEach(() => {
    if (!nock_1.default.isActive()) {
        nock_1.default.activate();
    }
    client = (0, base_1.createClient)();
    checkout = new checkout_1.default(client);
    scope = (0, nock_1.default)(`${client.config.checkoutEndpoint}/${client_1.default.CHECKOUT_API_VERSION}`);
});
afterEach(() => {
    nock_1.default.cleanAll();
});
describe("Modification", () => {
    test.each([isCI, true])("should perform an amount update request, isMock: %p", async (isMock) => {
        !isMock && nock_1.default.restore();
        const request = createAmountUpdateRequest();
        scope.post(`/payments/${paymentPspReference}/amountUpdates`)
            .reply(200, createAmountUpdateResponse());
        try {
            const result = await checkout.amountUpdates(paymentPspReference, request);
            expect(result).toBeTruthy();
        }
        catch (e) {
            if (e instanceof Error) {
                if (e.message)
                    fail(e.message);
            }
            else {
                fail();
            }
        }
    });
    test.each([false, true])("should fail to perform an amount update request, isMock: %p", async (isMock) => {
        !isMock && nock_1.default.restore();
        expect.assertions(2);
        const request = createAmountUpdateRequest();
        scope.post(`/payments/${invalidPaymentPspReference}/amountUpdates`)
            .reply(422, invalidModificationResult);
        try {
            await checkout.amountUpdates(invalidPaymentPspReference, request);
        }
        catch (e) {
            if (e instanceof httpClientException_1.default) {
                if (e.statusCode)
                    expect(e.statusCode).toBe(422);
                expect(e.message).toContain("Original pspReference required for this operation");
            }
            else {
                fail();
            }
        }
    });
    test.each([isCI, true])("should perform a cancels request, isMock: %p", async (isMock) => {
        !isMock && nock_1.default.restore();
        const request = createCancelsRequest();
        scope.post(`/payments/${paymentPspReference}/cancels`)
            .reply(200, createCancelsResponse());
        try {
            const result = await checkout.cancels(paymentPspReference, request);
            expect(result).toBeTruthy();
        }
        catch (e) {
            if (e instanceof Error) {
                if (e.message)
                    fail(e.message);
            }
            else {
                fail();
            }
        }
    });
    test.each([false, true])("should fail to perform a cancels request, isMock: %p", async (isMock) => {
        !isMock && nock_1.default.restore();
        expect.assertions(2);
        const request = createCancelsRequest();
        scope.post(`/payments/${invalidPaymentPspReference}/cancels`)
            .reply(422, invalidModificationResult);
        try {
            await checkout.cancels(invalidPaymentPspReference, request);
        }
        catch (e) {
            if (e instanceof httpClientException_1.default) {
                if (e.statusCode)
                    expect(e.statusCode).toBe(422);
                expect(e.message).toContain("Original pspReference required for this operation");
            }
            else {
                fail();
            }
        }
    });
    test.each([isCI, true])("should perform a standalone cancels request, isMock: %p", async (isMock) => {
        !isMock && nock_1.default.restore();
        const request = createStandaloneCancelsRequest();
        scope.post("/cancels")
            .reply(200, createStandaloneCancelsResponse());
        try {
            const result = await checkout.cancelsStandalone(request);
            expect(result).toBeTruthy();
        }
        catch (e) {
            if (e instanceof Error) {
                if (e.message)
                    fail(e.message);
            }
            else {
                fail();
            }
        }
    });
    test.each([isCI, true])("should perform a captures request, isMock: %p", async (isMock) => {
        !isMock && nock_1.default.restore();
        const request = createCapturesRequest();
        scope.post(`/payments/${paymentPspReference}/captures`)
            .reply(200, createCapturesResponse());
        try {
            const result = await checkout.captures(paymentPspReference, request);
            expect(result).toBeTruthy();
        }
        catch (e) {
            if (e instanceof Error) {
                if (e.message)
                    fail(e.message);
            }
            else {
                fail();
            }
        }
    });
    test.each([false, true])("should fail to perform a captures request, isMock: %p", async (isMock) => {
        !isMock && nock_1.default.restore();
        expect.assertions(2);
        const request = createCapturesRequest();
        scope.post(`/payments/${invalidPaymentPspReference}/captures`)
            .reply(422, invalidModificationResult);
        try {
            await checkout.captures(invalidPaymentPspReference, request);
        }
        catch (e) {
            if (e instanceof httpClientException_1.default) {
                if (e.statusCode)
                    expect(e.statusCode).toBe(422);
                expect(e.message).toContain("Original pspReference required for this operation");
            }
            else {
                fail();
            }
        }
    });
    test.each([isCI, true])("should perform a refunds request, isMock: %p", async (isMock) => {
        !isMock && nock_1.default.restore();
        const request = createRefundsRequest();
        scope.post(`/payments/${paymentPspReference}/refunds`)
            .reply(200, createRefundsResponse());
        try {
            const result = await checkout.refunds(paymentPspReference, request);
            expect(result).toBeTruthy();
        }
        catch (e) {
            if (e instanceof Error) {
                if (e.message)
                    fail(e.message);
            }
            else {
                fail();
            }
        }
    });
    test.each([false, true])("should fail to perform a refunds request, isMock: %p", async (isMock) => {
        !isMock && nock_1.default.restore();
        expect.assertions(2);
        const request = createRefundsRequest();
        scope.post(`/payments/${invalidPaymentPspReference}/refunds`)
            .reply(422, invalidModificationResult);
        try {
            await checkout.refunds(invalidPaymentPspReference, request);
        }
        catch (e) {
            if (e instanceof httpClientException_1.default) {
                if (e.statusCode)
                    expect(e.statusCode).toBe(422);
                expect(e.message).toContain("Original pspReference required for this operation");
            }
            else {
                fail();
            }
        }
    });
    test.each([isCI, true])("should perform a reversals request, isMock: %p", async (isMock) => {
        !isMock && nock_1.default.restore();
        const request = createReversalsRequest();
        scope.post(`/payments/${paymentPspReference}/reversals`)
            .reply(200, createReversalsResponse());
        try {
            const result = await checkout.reversals(paymentPspReference, request);
            expect(result).toBeTruthy();
        }
        catch (e) {
            if (e instanceof Error) {
                if (e.message)
                    fail(e.message);
            }
            else {
                fail();
            }
        }
    });
    test.each([false, true])("should fail to perform a reversals request, isMock: %p", async (isMock) => {
        !isMock && nock_1.default.restore();
        expect.assertions(2);
        const request = createReversalsRequest();
        scope.post(`/payments/${invalidPaymentPspReference}/reversals`)
            .reply(422, invalidModificationResult);
        try {
            await checkout.reversals(invalidPaymentPspReference, request);
        }
        catch (e) {
            if (e instanceof httpClientException_1.default) {
                if (e.statusCode)
                    expect(e.statusCode).toBe(422);
                expect(e.message).toContain("Original pspReference required for this operation");
            }
            else {
                fail();
            }
        }
    });
});
//# sourceMappingURL=modification.spec.js.map